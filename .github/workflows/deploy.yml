name: Build and deploy to Azure Container Apps

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      force_all:
        description: 'Deploy ALL services regardless of changed paths'
        type: boolean
        required: false
        default: false
      test_suite:
        description: 'Post-deployment integration test suite (auto=based on changes, all=everything, issuer=issuer-only, e2e=verifier+issuer)'
        type: choice
        options:
          - auto
          - all
          - issuer
          - e2e
        required: false
        default: 'auto'

permissions:
  contents: read
  id-token: write   # required for OIDC to Azure

jobs:
  # =========================================================================
  # DETECT CHANGED PATHS
  # =========================================================================
  # Determine which services have changed to skip unnecessary builds
  changes:
    runs-on: ubuntu-latest
    outputs:
      witness: ${{ inputs.force_all == true && 'true' || steps.filter.outputs.witness }}
      keri-agent: ${{ inputs.force_all == true && 'true' || steps.filter.outputs.keri-agent }}
      issuer: ${{ inputs.force_all == true && 'true' || steps.filter.outputs.issuer }}
      verifier: ${{ inputs.force_all == true && 'true' || steps.filter.outputs.verifier }}
      sip-redirect: ${{ inputs.force_all == true && 'true' || steps.filter.outputs.sip-redirect }}
      sip-verify: ${{ inputs.force_all == true && 'true' || steps.filter.outputs.sip-verify }}
      pbx-config: ${{ inputs.force_all == true && 'true' || steps.filter.outputs.pbx-config }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            witness:
              - 'services/witness/**'
            keri-agent:
              - 'services/keri-agent/**'
              - 'keripy/**'
              - 'common/**'
            issuer:
              - 'services/issuer/**'
              - 'common/**'
            verifier:
              - 'services/verifier/**'
              - 'common/**'
            sip-redirect:
              - 'services/sip-redirect/**'
              - 'common/**'
            sip-verify:
              - 'services/sip-verify/**'
              - 'common/**'
            pbx-config:
              - 'services/pbx/config/**'

  # =========================================================================
  # TEST JOBS - Run tests for all services
  # =========================================================================
  test-verifier:
    needs: [changes]
    if: needs.changes.outputs.verifier == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: services/verifier

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install libsodium
        working-directory: .
        run: |
          sudo apt-get update
          sudo apt-get install -y libsodium-dev
          ldconfig -p | grep libsodium || echo "libsodium found in apt paths"

      - name: Install common package
        working-directory: common
        run: pip install -e .

      - name: Install dependencies
        run: |
          pip install -e .
          pip install pytest pytest-asyncio pytest-cov

      - name: Verify pysodium import
        run: python3 -c "import pysodium; print('pysodium OK')"

      - name: Run tests with coverage
        run: |
          pytest tests/ -v --cov=app --cov-report=xml --cov-fail-under=79

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: services/verifier/coverage.xml
        continue-on-error: true

  test-keri-agent:
    needs: [changes]
    if: needs.changes.outputs.keri-agent == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: services/keri-agent

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install libsodium
        working-directory: .
        run: |
          sudo apt-get update
          sudo apt-get install -y libsodium-dev
          ldconfig -p | grep libsodium || echo "libsodium found in apt paths"

      - name: Install keripy (vendored)
        working-directory: .
        run: pip install keripy/

      - name: Install common package
        working-directory: common
        run: pip install -e .

      - name: Install dependencies
        run: |
          pip install -e .
          pip install pytest pytest-asyncio pytest-cov

      - name: Verify pysodium import
        run: python3 -c "import pysodium; print('pysodium OK')"

      - name: Run tests with coverage
        run: |
          pytest tests/ -v --cov=app --cov-report=xml --cov-fail-under=70

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: services/keri-agent/coverage.xml
        continue-on-error: true

  test-issuer:
    needs: [changes]
    if: needs.changes.outputs.issuer == 'true'
    runs-on: ubuntu-latest

    # Sprint 46: PostgreSQL service container for tests
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: vvpissuer_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      VVP_DATABASE_URL: postgresql+psycopg://test:test@localhost:5432/vvpissuer_test

    defaults:
      run:
        working-directory: services/issuer

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install libsodium
        working-directory: .
        run: |
          sudo apt-get update
          sudo apt-get install -y libsodium-dev
          ldconfig -p | grep libsodium || echo "libsodium found in apt paths"

      - name: Install common package
        working-directory: common
        run: pip install -e .

      - name: Install dependencies
        run: |
          pip install -e .
          pip install pytest pytest-asyncio pytest-cov

      - name: Verify pysodium import
        run: python3 -c "import pysodium; print('pysodium OK')"

      - name: Run tests with coverage
        run: |
          pytest tests/ -v --cov=app --cov-report=xml --cov-fail-under=60

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: services/issuer/coverage.xml
        continue-on-error: true

  # =========================================================================
  # TEST SIP REDIRECT SERVICE
  # =========================================================================
  # Only runs when sip-redirect code changes
  test-sip-redirect:
    needs: [changes]
    if: needs.changes.outputs.sip-redirect == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: services/sip-redirect

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install libsodium
        working-directory: .
        run: |
          sudo apt-get update
          sudo apt-get install -y libsodium-dev

      - name: Install common package
        working-directory: common
        run: pip install -e .

      - name: Install dependencies
        run: |
          pip install -e .
          pip install pytest pytest-asyncio aiohttp

      - name: Run tests
        run: |
          pytest tests/ -v

  # =========================================================================
  # TEST SIP VERIFY SERVICE
  # =========================================================================
  # Only runs when sip-verify code changes
  test-sip-verify:
    needs: [changes]
    if: needs.changes.outputs.sip-verify == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: services/sip-verify

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install libsodium
        working-directory: .
        run: |
          sudo apt-get update
          sudo apt-get install -y libsodium-dev

      - name: Install common package
        working-directory: common
        run: pip install -e .

      - name: Install dependencies
        run: |
          pip install -e .
          pip install pytest pytest-asyncio aiohttp httpx

      - name: Run tests
        run: |
          pytest tests/ -v

  # =========================================================================
  # DEPLOY VERIFIER
  # =========================================================================
  deploy-verifier:
    needs: [changes, test-verifier]
    if: needs.changes.outputs.verifier == 'true' && !failure()
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login -n "${{ secrets.ACR_NAME }}"

      - name: Build and push verifier image
        run: |
          IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/vvp-verifier:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          docker build -t "$IMAGE" -f services/verifier/Dockerfile .
          docker push "$IMAGE"

      - name: Deploy verifier
        run: |
          az containerapp update \
            --resource-group "${{ secrets.AZURE_RG }}" \
            --name "${{ secrets.AZURE_CONTAINERAPP_NAME }}" \
            --image "$IMAGE" \
            --min-replicas 1 \
            --set-env-vars \
              "GIT_SHA=${{ github.sha }}" \
              "GITHUB_REPOSITORY=${{ github.repository }}" \
              "VVP_LOCAL_WITNESS_URLS=https://vvp-witness1.rcnx.io,https://vvp-witness2.rcnx.io,https://vvp-witness3.rcnx.io"

      - name: Verify deployed version
        run: |
          EXPECTED="${{ github.sha }}"
          for i in {1..12}; do
            RESPONSE=$(curl -sf --max-time 10 https://vvp-verifier.rcnx.io/version || echo '{}')
            DEPLOYED=$(echo "$RESPONSE" | jq -r '.git_sha // empty')
            if [ "$DEPLOYED" = "$EXPECTED" ]; then
              echo "Version verified: ${DEPLOYED:0:7}"
              exit 0
            fi
            echo "Attempt $i/12: expected ${EXPECTED:0:7}, got ${DEPLOYED:0:7}"
            sleep 10
          done
          echo "::error::Verifier version mismatch after 2 minutes"
          exit 1

  # =========================================================================
  # DEPLOY KERI AGENT
  # =========================================================================
  # Sprint 69: LMDB is now ephemeral (local tmpfs). Key seeds are persisted
  # to PostgreSQL and state is rebuilt deterministically on startup.
  # No stop-before-deploy needed — standard rolling update.
  # Only redeploys when keripy, keri-agent code, or common changes.
  deploy-keri-agent:
    needs: [changes, test-keri-agent, verify-witnesses]
    # Deploy if keri-agent changed AND no upstream failures.
    # When witnesses also changed, waits for verify-witnesses to complete
    # so KERI Agent publishes to stable witnesses (not mid-restart ones).
    # When witnesses didn't change, verify-witnesses is skipped (not failure).
    if: |
      needs.changes.outputs.keri-agent == 'true' && !failure() &&
      (needs.changes.outputs.witness != 'true' || needs.verify-witnesses.result != 'failure')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login -n "${{ secrets.ACR_NAME }}"

      - name: Build and push keri-agent image
        run: |
          IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/vvp-keri-agent:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          docker build -t "$IMAGE" -f services/keri-agent/Dockerfile .
          docker push "$IMAGE"

      - name: Ensure keri-agent container app exists
        id: ensure_agent
        run: |
          RG="${{ secrets.AZURE_RG }}"

          # Check if app exists and is healthy
          PROVISION_STATE=$(az containerapp show --name vvp-keri-agent --resource-group "$RG" \
            --query "properties.provisioningState" -o tsv 2>/dev/null || echo "NotFound")

          if [ "$PROVISION_STATE" = "Failed" ]; then
            echo "::warning::vvp-keri-agent exists in Failed state — deleting and recreating..."
            az containerapp delete --name vvp-keri-agent --resource-group "$RG" --yes 2>/dev/null || true
            PROVISION_STATE="NotFound"
          fi

          if [ "$PROVISION_STATE" != "NotFound" ]; then
            echo "vvp-keri-agent already exists (state: $PROVISION_STATE)"
            echo "created=false" >> $GITHUB_OUTPUT
          else
            echo "vvp-keri-agent does not exist — provisioning..."

            # Discover Container App Environment from existing issuer
            ENV_ID=$(az containerapp show --name vvp-issuer --resource-group "$RG" \
              --query "properties.managedEnvironmentId" -o tsv)
            echo "Environment ID: $ENV_ID"

            # Get ACR credentials for the new container app to pull images
            ACR_SERVER="${{ secrets.ACR_LOGIN_SERVER }}"
            ACR_USER=$(az acr credential show -n "${{ secrets.ACR_NAME }}" --query username -o tsv)
            ACR_PASS=$(az acr credential show -n "${{ secrets.ACR_NAME }}" --query 'passwords[0].value' -o tsv)

            # Create with internal-only ingress, single replica, paused (min 0)
            # Sprint 69: No Azure Files volume — LMDB is ephemeral on local tmpfs
            az containerapp create \
              --name vvp-keri-agent \
              --resource-group "$RG" \
              --environment "$ENV_ID" \
              --image "$IMAGE" \
              --registry-server "$ACR_SERVER" \
              --registry-username "$ACR_USER" \
              --registry-password "$ACR_PASS" \
              --target-port 8002 \
              --ingress internal \
              --min-replicas 0 \
              --max-replicas 1 \
              --cpu 1.0 \
              --memory 2Gi \
              --env-vars \
                "GIT_SHA=${{ github.sha }}" \
                "GITHUB_REPOSITORY=${{ github.repository }}" \
                "VVP_WITNESS_CONFIG=/srv/config/witnesses-azure.json" \
                "VVP_MOCK_VLEI_ENABLED=true" \
                "VVP_KERI_AGENT_DATA_DIR=/tmp/vvp-keri-agent"

            echo "vvp-keri-agent created successfully"
            echo "created=true" >> $GITHUB_OUTPUT
          fi

      - name: Set keri-agent secrets
        run: |
          SECRETS=()
          TOKEN="${{ secrets.KERI_AGENT_AUTH_TOKEN }}"
          if [ -n "$TOKEN" ]; then
            SECRETS+=("keri-agent-auth-token=$TOKEN")
          else
            echo "::warning::KERI_AGENT_AUTH_TOKEN secret not set — keri-agent running without inter-service auth"
          fi

          # Sprint 69: Database URL for seed persistence
          DB_URL="${{ secrets.KERI_AGENT_DATABASE_URL }}"
          if [ -n "$DB_URL" ]; then
            SECRETS+=("keri-agent-db-url=$DB_URL")
          else
            echo "::warning::KERI_AGENT_DATABASE_URL secret not set — keri-agent will use local SQLite (ephemeral!)"
          fi

          if [ ${#SECRETS[@]} -gt 0 ]; then
            az containerapp secret set \
              --resource-group "${{ secrets.AZURE_RG }}" \
              --name "vvp-keri-agent" \
              --secrets "${SECRETS[@]}"
          fi

      - name: Deploy keri-agent
        run: |
          # Build env-vars list
          # Sprint 69: LMDB is ephemeral (local /tmp), seeds persisted to PG
          ENV_VARS=(
            "GIT_SHA=${{ github.sha }}"
            "GITHUB_REPOSITORY=${{ github.repository }}"
            "VVP_WITNESS_CONFIG=/srv/config/witnesses-azure.json"
            "VVP_MOCK_VLEI_ENABLED=true"
            "VVP_KERI_AGENT_DATA_DIR=/tmp/vvp-keri-agent"
          )

          # Only reference secrets if they were set
          TOKEN="${{ secrets.KERI_AGENT_AUTH_TOKEN }}"
          if [ -n "$TOKEN" ]; then
            ENV_VARS+=("VVP_KERI_AGENT_AUTH_TOKEN=secretref:keri-agent-auth-token")
          fi

          DB_URL="${{ secrets.KERI_AGENT_DATABASE_URL }}"
          if [ -n "$DB_URL" ]; then
            ENV_VARS+=("VVP_KERI_AGENT_DATABASE_URL=secretref:keri-agent-db-url")
          fi

          az containerapp update \
            --resource-group "${{ secrets.AZURE_RG }}" \
            --name "vvp-keri-agent" \
            --image "$IMAGE" \
            --min-replicas 1 \
            --max-replicas 1 \
            --set-env-vars "${ENV_VARS[@]}"

      - name: Ensure new revision is active
        run: |
          RG="${{ secrets.AZURE_RG }}"
          NEW_REV=$(az containerapp show \
            --name vvp-keri-agent \
            --resource-group "$RG" \
            --query "properties.latestRevisionName" -o tsv)

          echo "New revision: $NEW_REV"

          if [ -z "$NEW_REV" ]; then
            echo "::error::Could not determine latest revision name"
            exit 1
          fi

          IS_ACTIVE=$(az containerapp revision show \
            --name vvp-keri-agent \
            --resource-group "$RG" \
            --revision "$NEW_REV" \
            --query "properties.active" -o tsv)

          echo "Revision $NEW_REV active=$IS_ACTIVE"

          if [ "$IS_ACTIVE" != "true" ]; then
            echo "::warning::New revision is not active — activating explicitly"
            az containerapp revision activate \
              --name vvp-keri-agent \
              --resource-group "$RG" \
              --revision "$NEW_REV"
            echo "Activated revision $NEW_REV"
            sleep 5

            IS_ACTIVE=$(az containerapp revision show \
              --name vvp-keri-agent \
              --resource-group "$RG" \
              --revision "$NEW_REV" \
              --query "properties.active" -o tsv)

            if [ "$IS_ACTIVE" != "true" ]; then
              echo "::error::Failed to activate revision $NEW_REV"
              az containerapp revision list \
                --name vvp-keri-agent \
                --resource-group "$RG" \
                --query "[].{name:name, active:properties.active, state:properties.runningState, replicas:properties.replicas, traffic:properties.trafficWeight}" -o table 2>/dev/null || true
              exit 1
            fi
          fi

          echo "Revision $NEW_REV is active and should be starting"

      - name: Verify keri-agent running
        run: |
          # KERI Agent has internal-only ingress — not reachable from GitHub Actions.
          # Instead, poll the revision's running state via Azure CLI.
          # Sprint 70: Rebuild includes 69+ identities, registries, credentials,
          # and witness publishing (~53s rebuild + ~30s startup). Poll for 4 minutes.
          RG="${{ secrets.AZURE_RG }}"
          NEW_REV=$(az containerapp show \
            --name vvp-keri-agent \
            --resource-group "$RG" \
            --query "properties.latestRevisionName" -o tsv)
          echo "Monitoring revision: $NEW_REV"

          INTERVALS=(15 15 15 15 20 20 20 20 30 30)
          TOTAL=${#INTERVALS[@]}
          for i in "${!INTERVALS[@]}"; do
            ATTEMPT=$((i + 1))
            STATE=$(az containerapp revision show \
              --name vvp-keri-agent \
              --resource-group "$RG" \
              --revision "$NEW_REV" \
              --query "properties.runningState" -o tsv 2>/dev/null || echo "Unknown")
            REPLICAS=$(az containerapp revision show \
              --name vvp-keri-agent \
              --resource-group "$RG" \
              --revision "$NEW_REV" \
              --query "properties.replicas" -o tsv 2>/dev/null || echo "0")

            echo "Attempt ${ATTEMPT}/${TOTAL}: state=$STATE replicas=$REPLICAS"

            # Running* matches Running, RunningAtMaxScale, and any future variants
            if [[ "$STATE" == Running* ]] && [ "$REPLICAS" -gt 0 ] 2>/dev/null; then
              echo "KERI Agent revision $NEW_REV is running (state=$STATE) with $REPLICAS replica(s)"
              exit 0
            fi

            if [ "$STATE" = "Failed" ] || [ "$STATE" = "Degraded" ] || [ "$STATE" = "Stopped" ]; then
              echo "::error::KERI Agent revision $NEW_REV is in $STATE state"
              az containerapp revision show \
                --name vvp-keri-agent \
                --resource-group "$RG" \
                --revision "$NEW_REV" -o json 2>/dev/null || true
              exit 1
            fi

            sleep "${INTERVALS[$i]}"
          done
          echo "::error::KERI Agent did not reach Running state within 4 minutes"
          az containerapp revision show \
            --name vvp-keri-agent \
            --resource-group "$RG" \
            --revision "$NEW_REV" -o json 2>/dev/null || true
          exit 1

  # =========================================================================
  # DEPLOY ISSUER
  # =========================================================================
  # Sprint 68: Issuer no longer owns LMDB — standard deploy, no lock handling.
  # When both keri-agent and issuer change, issuer deploys AFTER keri-agent.
  deploy-issuer:
    needs: [changes, test-issuer, deploy-keri-agent]
    # Run if issuer changed AND (keri-agent didn't change OR keri-agent deployed successfully)
    if: |
      needs.changes.outputs.issuer == 'true' && !failure() &&
      (needs.changes.outputs.keri-agent != 'true' || needs.deploy-keri-agent.result == 'success')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login -n "${{ secrets.ACR_NAME }}"

      - name: Build and push issuer image
        run: |
          IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/vvp-issuer:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          docker build -t "$IMAGE" -f services/issuer/Dockerfile .
          docker push "$IMAGE"

      - name: Set issuer secrets
        run: |
          TOKEN="${{ secrets.KERI_AGENT_AUTH_TOKEN }}"
          if [ -n "$TOKEN" ]; then
            az containerapp secret set \
              --resource-group "${{ secrets.AZURE_RG }}" \
              --name "vvp-issuer" \
              --secrets "keri-agent-auth-token=$TOKEN"
          else
            echo "::warning::KERI_AGENT_AUTH_TOKEN secret not set — issuer will connect to keri-agent without auth"
          fi

      - name: Deploy issuer
        run: |
          RG="${{ secrets.AZURE_RG }}"

          # Discover keri-agent internal FQDN from Azure (works regardless of custom DNS)
          KERI_AGENT_FQDN=$(az containerapp show --name vvp-keri-agent --resource-group "$RG" \
            --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || echo "")
          if [ -n "$KERI_AGENT_FQDN" ]; then
            KERI_AGENT_URL="https://$KERI_AGENT_FQDN"
            echo "Discovered keri-agent URL: $KERI_AGENT_URL"
          else
            KERI_AGENT_URL="https://vvp-keri-agent.internal.rcnx.io"
            echo "::warning::Could not discover keri-agent FQDN — using fallback: $KERI_AGENT_URL"
          fi

          # Build env-vars list
          ENV_VARS=(
            "GIT_SHA=${{ github.sha }}"
            "GITHUB_REPOSITORY=${{ github.repository }}"
            "VVP_WITNESS_CONFIG=/srv/config/witnesses-azure.json"
            "VVP_POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}"
            "VVP_POSTGRES_USER=${{ secrets.POSTGRES_USER }}"
            "VVP_POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}"
            "VVP_POSTGRES_DB=${{ secrets.POSTGRES_DB }}"
            "VVP_ISSUER_BASE_URL=https://vvp-issuer.rcnx.io"
            "VVP_KERI_AGENT_URL=$KERI_AGENT_URL"
            "AZURE_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          )

          # Only reference secret if it was set
          TOKEN="${{ secrets.KERI_AGENT_AUTH_TOKEN }}"
          if [ -n "$TOKEN" ]; then
            ENV_VARS+=("VVP_KERI_AGENT_AUTH_TOKEN=secretref:keri-agent-auth-token")
          fi

          az containerapp update \
            --resource-group "${{ secrets.AZURE_RG }}" \
            --name "vvp-issuer" \
            --image "$IMAGE" \
            --min-replicas 1 \
            --max-replicas 3 \
            --set-env-vars "${ENV_VARS[@]}"

      - name: Verify deployed version
        run: |
          EXPECTED="${{ github.sha }}"
          # Issuer no longer needs LMDB init — should be fast (~30s).
          # Poll for 2 minutes max.
          for i in {1..12}; do
            RESPONSE=$(curl -sf --max-time 10 https://vvp-issuer.rcnx.io/version || echo '{}')
            DEPLOYED=$(echo "$RESPONSE" | jq -r '.git_sha // empty')
            if [ "$DEPLOYED" = "$EXPECTED" ]; then
              echo "Version verified: ${DEPLOYED:0:7}"
              exit 0
            fi
            echo "Attempt $i/12: expected ${EXPECTED:0:7}, got ${DEPLOYED:0:7}"
            sleep 10
          done
          echo "::error::Issuer version mismatch after 2 minutes"
          exit 1

  # =========================================================================
  # BUILD WITNESS IMAGE
  # =========================================================================
  # Build the custom witness image once, then deploy to all witnesses
  # Only runs when witness code changes
  build-witness-image:
    needs: [changes]
    # Witness builds are independent of verifier/issuer tests.
    # Only gate on witness path changes being detected.
    if: needs.changes.outputs.witness == 'true'
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build.outputs.image }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: |
          az acr login -n "${{ secrets.ACR_NAME }}"

      - name: Build and push witness image
        id: build
        run: |
          IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/vvp-witness:${{ github.sha }}"
          echo "Building witness image: $IMAGE"
          docker build --platform linux/amd64 -t "$IMAGE" -f services/witness/Dockerfile .
          docker push "$IMAGE"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

  # =========================================================================
  # DEPLOY WITNESSES
  # =========================================================================
  # Deploy the custom witness image to each witness container app
  # Only runs when witness code changes
  deploy-witnesses:
    needs: [changes, build-witness-image]
    if: needs.changes.outputs.witness == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        witness:
          - name: vvp-witness1
            witness_name: wan
            http_port: 5642
            tcp_port: 5632
          - name: vvp-witness2
            witness_name: wil
            http_port: 5643
            tcp_port: 5633
          - name: vvp-witness3
            witness_name: wes
            http_port: 5644
            tcp_port: 5634

    env:
      WITNESS_IMAGE: ${{ needs.build-witness-image.outputs.image }}

    steps:
      - name: Validate image output
        run: |
          if [ -z "$WITNESS_IMAGE" ]; then
            echo "WARNING: Witness image output is empty, constructing from secrets"
            # Fallback: construct image URL directly
            WITNESS_IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/vvp-witness:${{ github.sha }}"
            echo "WITNESS_IMAGE=$WITNESS_IMAGE" >> $GITHUB_ENV
          fi
          echo "Using witness image: $WITNESS_IMAGE"

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deactivate old revisions
        run: |
          echo "Deactivating old revisions for ${{ matrix.witness.name }}..."
          # List all active revisions and deactivate them before deploying.
          # This prevents LMDB lock conflicts between old and new revisions.
          REVISIONS=$(az containerapp revision list \
            --name ${{ matrix.witness.name }} \
            --resource-group ${{ secrets.AZURE_RG }} \
            --query "[?properties.active].name" -o tsv)
          for REV in $REVISIONS; do
            echo "Deactivating revision: $REV"
            az containerapp revision deactivate \
              --name ${{ matrix.witness.name }} \
              --resource-group ${{ secrets.AZURE_RG }} \
              --revision "$REV" || true
          done

      - name: Deploy witness
        run: |
          echo "Deploying ${{ matrix.witness.name }} with image: $WITNESS_IMAGE"

          # Update the container app with the new image and environment variables.
          # KERI_DB_PATH=/tmp/witness uses ephemeral container storage — witnesses
          # use deterministic salts so they recreate the same AID on every restart.
          az containerapp update \
            --name ${{ matrix.witness.name }} \
            --resource-group ${{ secrets.AZURE_RG }} \
            --image "$WITNESS_IMAGE" \
            --set-env-vars \
              "WITNESS_NAME=${{ matrix.witness.witness_name }}" \
              "HTTP_PORT=${{ matrix.witness.http_port }}" \
              "TCP_PORT=${{ matrix.witness.tcp_port }}" \
              "KERI_DB_PATH=/tmp/witness" \
              "GIT_SHA=${{ github.sha }}"

      - name: Wait for witness to be ready
        run: |
          echo "Waiting for witness ${{ matrix.witness.name }} to be ready..."
          for i in {1..30}; do
            STATUS=$(az containerapp show \
              --name ${{ matrix.witness.name }} \
              --resource-group ${{ secrets.AZURE_RG }} \
              --query "properties.runningStatus" -o tsv)
            if [ "$STATUS" = "Running" ]; then
              echo "Witness is running"
              break
            fi
            echo "Attempt $i/30: Status is $STATUS, waiting..."
            sleep 10
          done

  # =========================================================================
  # VERIFY WITNESSES
  # =========================================================================
  # Only runs when witness code changes
  verify-witnesses:
    needs: [changes, deploy-witnesses]
    if: needs.changes.outputs.witness == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        witness:
          - name: vvp-witness1
            aid: BBilc4-L3tFUnfM_wJr4S4OJanAv_VmF_dJNN6vkf2Ha
          - name: vvp-witness2
            aid: BLskRTInXnMxWaGqcpSyMgo0nYbalW99cGZESrz3zapM
          - name: vvp-witness3
            aid: BIKKuvBwpmDVA4Ds-EpL5bt9OqPzWPja2LigFYZN2YfX

    steps:
      - name: Verify witness OOBI endpoint
        run: |
          WITNESS_URL="https://${{ matrix.witness.name }}.rcnx.io"
          OOBI_URL="${WITNESS_URL}/oobi/${{ matrix.witness.aid }}/controller"
          echo "Checking OOBI endpoint: $OOBI_URL"

          # Retry a few times in case witness is still warming up
          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$OOBI_URL" || echo "000")
            echo "Attempt $i: HTTP response code: $HTTP_CODE"
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "202" ]; then
              echo "Witness OOBI endpoint is healthy"
              exit 0
            fi
            sleep 10
          done

          echo "::warning::Witness OOBI endpoint returned $HTTP_CODE after 5 attempts"

  # =========================================================================
  # POST-DEPLOYMENT INTEGRATION TESTS
  # =========================================================================
  # Run selective integration tests after deployment based on which services changed.
  post-deployment-tests:
    needs: [changes, deploy-verifier, deploy-issuer, deploy-keri-agent]
    if: (needs.changes.outputs.verifier == 'true' || needs.changes.outputs.issuer == 'true' || needs.changes.outputs.keri-agent == 'true') && !failure()
    runs-on: ubuntu-latest

    env:
      VVP_ISSUER_URL: https://vvp-issuer.rcnx.io
      VVP_VERIFIER_URL: https://vvp-verifier.rcnx.io
      VVP_TEST_MODE: azure

    steps:
      - name: Determine test suite
        id: suite
        run: |
          ISSUER_CHANGED="${{ needs.changes.outputs.issuer }}"
          VERIFIER_CHANGED="${{ needs.changes.outputs.verifier }}"
          KERI_AGENT_CHANGED="${{ needs.changes.outputs.keri-agent }}"
          SUITE_OVERRIDE="${{ inputs.test_suite }}"

          # Default to auto if not specified (push trigger has no inputs)
          if [ -z "$SUITE_OVERRIDE" ] || [ "$SUITE_OVERRIDE" = "auto" ]; then
            if [ "$ISSUER_CHANGED" = "true" ] && [ "$VERIFIER_CHANGED" = "true" ]; then
              MARKERS="integration and not benchmark"
              SUITE_NAME="all (both services changed)"
            elif [ "$ISSUER_CHANGED" = "true" ] || [ "$KERI_AGENT_CHANGED" = "true" ]; then
              MARKERS="integration and issuer and not benchmark"
              SUITE_NAME="issuer-only (verifier unchanged)"
            elif [ "$VERIFIER_CHANGED" = "true" ]; then
              MARKERS="integration and e2e and not benchmark"
              SUITE_NAME="e2e-only (issuer unchanged)"
            else
              MARKERS="integration and not benchmark"
              SUITE_NAME="all (fallback)"
            fi
          elif [ "$SUITE_OVERRIDE" = "all" ]; then
            MARKERS="integration and not benchmark"
            SUITE_NAME="all (manual override)"
          elif [ "$SUITE_OVERRIDE" = "issuer" ]; then
            MARKERS="integration and issuer and not benchmark"
            SUITE_NAME="issuer-only (manual override)"
          elif [ "$SUITE_OVERRIDE" = "e2e" ]; then
            MARKERS="integration and e2e and not benchmark"
            SUITE_NAME="e2e-only (manual override)"
          fi

          echo "markers=$MARKERS" >> $GITHUB_OUTPUT
          echo "suite_name=$SUITE_NAME" >> $GITHUB_OUTPUT
          echo "Selected test suite: $SUITE_NAME"
          echo "Marker expression: $MARKERS"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install libsodium
        run: |
          sudo apt-get update
          sudo apt-get install -y libsodium-dev

      - name: Install common package
        working-directory: common
        run: pip install -e .

      - name: Install test dependencies
        run: |
          pip install pytest pytest-asyncio aiohttp httpx pysodium azure-storage-blob

      - name: Wait for services to be ready
        run: |
          echo "Waiting for issuer and verifier to be ready..."
          for i in {1..30}; do
            ISSUER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$VVP_ISSUER_URL/healthz" || echo "000")
            VERIFIER_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$VVP_VERIFIER_URL/healthz" || echo "000")
            echo "Attempt $i/30: Issuer=$ISSUER_STATUS, Verifier=$VERIFIER_STATUS"
            if [ "$ISSUER_STATUS" = "200" ] && [ "$VERIFIER_STATUS" = "200" ]; then
              echo "Both services are ready"
              break
            fi
            sleep 10
          done

      - name: Bootstrap test org (self-healing)
        id: bootstrap
        env:
          VVP_SYSTEM_ADMIN_KEY: ${{ secrets.VVP_SYSTEM_ADMIN_KEY }}
        run: |
          # Ensure ACME Inc org and API key exist. Uses --skip-reinit so it never
          # wipes production data — finds existing org or creates one if absent.
          python3 scripts/bootstrap-issuer.py \
            --url "$VVP_ISSUER_URL" \
            --admin-key "$VVP_SYSTEM_ADMIN_KEY" \
            --org-name "ACME Inc" \
            --skip-reinit \
            --json-file bootstrap_summary.json
          ORG_ID=$(python3 -c "import json; d=json.load(open('bootstrap_summary.json')); print(d['organization']['id'])")
          API_KEY=$(python3 -c "import json; d=json.load(open('bootstrap_summary.json')); print(d['org_api_key']['raw_key'])")
          echo "org_id=$ORG_ID" >> $GITHUB_OUTPUT
          echo "api_key=$API_KEY" >> $GITHUB_OUTPUT
          echo "Bootstrap: org_id=$ORG_ID"

      - name: Smoke tests (fast critical-path check)
        id: smoke_tests
        env:
          VVP_TEST_API_KEY: ${{ steps.bootstrap.outputs.api_key }}
          VVP_TEST_ORG_ID: ${{ steps.bootstrap.outputs.org_id }}
          VVP_TEST_ADMIN_KEY: ${{ secrets.VVP_SYSTEM_ADMIN_KEY }}
        run: |
          # Run only smoke-marked tests first. These cover the critical path
          # (credential issuance + dossier) and give fast signal if deployment is broken.
          # -x stops on first failure so we don't wait for all smoke tests to finish.
          SMOKE_MARKERS="${{ steps.suite.outputs.markers }} and smoke"
          echo "Smoke markers: $SMOKE_MARKERS"

          set +e
          set -o pipefail
          python -m pytest tests/integration/ \
            -v \
            --tb=short \
            -x \
            -m "$SMOKE_MARKERS" \
            --ignore=tests/integration/benchmarks/ \
            2>&1 | tee smoke_output.txt
          echo "exit_code=$?" >> $GITHUB_OUTPUT

      - name: Full integration tests
        id: integration_tests
        if: steps.smoke_tests.outputs.exit_code == '0'
        env:
          VVP_TEST_API_KEY: ${{ steps.bootstrap.outputs.api_key }}
          VVP_TEST_ORG_ID: ${{ steps.bootstrap.outputs.org_id }}
          VVP_TEST_ADMIN_KEY: ${{ secrets.VVP_SYSTEM_ADMIN_KEY }}
          VVP_AZURE_STORAGE_CONNECTION_STRING: ${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}
        run: |
          echo "Smoke passed. Running full suite: ${{ steps.suite.outputs.suite_name }}"
          START_TIME=$(date +%s)
          set +e
          set -o pipefail

          python -m pytest tests/integration/ \
            -v \
            --tb=short \
            -m "${{ steps.suite.outputs.markers }} and not smoke" \
            --ignore=tests/integration/benchmarks/ \
            2>&1 | tee test_output.txt

          TEST_EXIT_CODE=$?
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))

          # Combine smoke + full counts for reporting
          SMOKE_PASSED=$(grep -oP '\d+(?= passed)' smoke_output.txt | tail -1 || echo "0")
          FULL_PASSED=$(grep -oP '\d+(?= passed)' test_output.txt | tail -1 || echo "0")
          FULL_FAILED=$(grep -oP '\d+(?= failed)' test_output.txt | tail -1 || echo "0")
          PASSED=$((SMOKE_PASSED + FULL_PASSED))
          FAILED=$FULL_FAILED
          TOTAL=$((PASSED + FAILED))

          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "duration=$DURATION" >> $GITHUB_OUTPUT
          echo "exit_code=$TEST_EXIT_CODE" >> $GITHUB_OUTPUT

          if [ $TEST_EXIT_CODE -ne 0 ]; then
            grep -A 5 "FAILED\|ERROR" test_output.txt > errors.txt || true
          fi

          exit $TEST_EXIT_CODE

      - name: Collect smoke failure details
        if: steps.smoke_tests.outputs.exit_code != '0'
        run: |
          grep -A 5 "FAILED\|ERROR" smoke_output.txt > errors.txt || true
          echo "exit_code=1" >> $GITHUB_OUTPUT
          echo "passed=0" >> $GITHUB_OUTPUT
          echo "failed=1" >> $GITHUB_OUTPUT
          echo "total=1" >> $GITHUB_OUTPUT
          echo "duration=0" >> $GITHUB_OUTPUT
          echo "##[error]Smoke tests FAILED — see smoke_output.txt for details"
          exit 1
        id: smoke_failure

      - name: Submit test results to admin endpoint
        if: always()
        env:
          VVP_TEST_API_KEY: ${{ secrets.VVP_ADMIN_API_KEY }}
        run: |
          # Determine overall pass/fail: both smoke and full must pass
          SMOKE_OK="${{ steps.smoke_tests.outputs.exit_code }}"
          FULL_OK="${{ steps.integration_tests.outputs.exit_code }}"
          if [ "$SMOKE_OK" = "0" ] && [ "$FULL_OK" = "0" ]; then
            PASSED_STATUS=true
          else
            PASSED_STATUS=false
          fi

          # Collect errors if any
          ERRORS="[]"
          if [ -f errors.txt ]; then
            ERRORS=$(cat errors.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          fi

          # Submit results
          curl -X POST "${VVP_ISSUER_URL}/admin/deployment-tests" \
            -H "X-API-Key: ${VVP_TEST_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
          {
            "git_sha": "${{ github.sha }}",
            "passed": ${PASSED_STATUS},
            "total_tests": ${{ steps.integration_tests.outputs.total || steps.smoke_failure.outputs.total || 0 }},
            "passed_tests": ${{ steps.integration_tests.outputs.passed || steps.smoke_failure.outputs.passed || 0 }},
            "failed_tests": ${{ steps.integration_tests.outputs.failed || steps.smoke_failure.outputs.failed || 0 }},
            "duration_seconds": ${{ steps.integration_tests.outputs.duration || steps.smoke_failure.outputs.duration || 0 }},
            "issuer_url": "${VVP_ISSUER_URL}",
            "verifier_url": "${VVP_VERIFIER_URL}",
            "errors": ${ERRORS}
          }
          EOF

          echo "Test results submitted to ${VVP_ISSUER_URL}/admin/deployment-tests"

      - name: Cleanup test identities
        if: always()
        env:
          VVP_TEST_ADMIN_KEY: ${{ secrets.VVP_SYSTEM_ADMIN_KEY }}
        run: |
          echo "Cleaning up test identities (metadata_type=test)..."
          RESULT=$(curl -s -X POST "${VVP_ISSUER_URL}/admin/cleanup/identities" \
            -H "X-API-Key: ${VVP_TEST_ADMIN_KEY}" \
            -H "Content-Type: application/json" \
            -d '{"metadata_type": "test", "cascade_credentials": true, "force": true}')
          DELETED=$(echo "$RESULT" | python3 -c "import sys,json; print(json.load(sys.stdin).get('deleted_count',0))" 2>/dev/null || echo "unknown")
          echo "Deleted $DELETED test identities"

      - name: Upload test artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: |
            smoke_output.txt
            test_output.txt
            errors.txt
          retention-days: 7

  # =========================================================================
  # DEPLOY SIP REDIRECT SERVICE (PBX VM)
  # =========================================================================
  # Deploys to vvp-pbx VM with atomic symlink switch and rollback capability
  # Only runs when sip-redirect code changes and tests pass
  deploy-sip-redirect:
    needs: [changes, test-sip-redirect]
    if: needs.changes.outputs.sip-redirect == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Package service
        run: |
          VERSION="${{ github.sha }}"
          tar -czf "sip-redirect-${VERSION}.tar.gz" -C services/sip-redirect app/ pyproject.toml
          echo "Created package: sip-redirect-${VERSION}.tar.gz"
          ls -la "sip-redirect-${VERSION}.tar.gz"

      - name: Upload to Azure Blob
        run: |
          VERSION="${{ github.sha }}"
          az storage blob upload \
            --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
            --container-name deployments \
            --name "sip-redirect/sip-redirect-${VERSION}.tar.gz" \
            --file "sip-redirect-${VERSION}.tar.gz" \
            --auth-mode login \
            --overwrite

      - name: Generate short-lived SAS URL (5 min expiry)
        id: sas
        run: |
          VERSION="${{ github.sha }}"
          EXPIRY=$(date -u -d "+5 minutes" '+%Y-%m-%dT%H:%MZ')
          SAS_URL=$(az storage blob generate-sas \
            --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
            --container-name deployments \
            --name "sip-redirect/sip-redirect-${VERSION}.tar.gz" \
            --permissions r \
            --expiry "$EXPIRY" \
            --auth-mode login \
            --as-user \
            --full-uri \
            --output tsv)
          echo "url=$SAS_URL" >> $GITHUB_OUTPUT

      - name: Deploy, update systemd, and restart
        run: |
          VERSION="${{ github.sha }}"
          SAS_URL="${{ steps.sas.outputs.url }}"
          # Base64-encode the systemd unit to avoid YAML escaping issues
          UNIT_B64=$(echo -e '[Unit]\nDescription=VVP SIP Redirect Signing Service\nAfter=network.target\n\n[Service]\nType=simple\nUser=root\nEnvironmentFile=/etc/vvp/sip-redirect.env\nWorkingDirectory=/opt/vvp/sip-redirect/current\nExecStart=/opt/vvp/venv/bin/python3 -m app.main\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n' | base64 -w0)
          # Single az vm run-command to avoid serialization conflicts
          # (Azure only allows one run-command at a time per VM)
          az vm run-command invoke \
            --resource-group VVP --name vvp-pbx \
            --command-id RunShellScript \
            --scripts "
              set -e
              VERSION='${VERSION}'
              DEPLOY_DIR=/opt/vvp/sip-redirect

              # --- Phase 1: Deploy code ---

              # Ensure venv exists with required packages (Sprint 47: monitoring dashboard)
              if [ ! -d /opt/vvp/venv ]; then
                python3 -m venv /opt/vvp/venv
              fi
              /opt/vvp/venv/bin/pip install -q aiohttp bcrypt

              # Download using SAS URL (no az CLI needed on VM)
              curl -sSL -o /tmp/sip-redirect-\${VERSION}.tar.gz '${SAS_URL}'

              # Extract to versioned directory
              mkdir -p \${DEPLOY_DIR}/releases/\${VERSION}
              tar -xzf /tmp/sip-redirect-\${VERSION}.tar.gz -C \${DEPLOY_DIR}/releases/\${VERSION}

              # Atomic symlink switch
              ln -sfn \${DEPLOY_DIR}/releases/\${VERSION} \${DEPLOY_DIR}/current.new
              mv -Tf \${DEPLOY_DIR}/current.new \${DEPLOY_DIR}/current

              # Cleanup old releases (keep last 3)
              cd \${DEPLOY_DIR}/releases && ls -t | tail -n +4 | xargs -r rm -rf

              # Cleanup temp file
              rm -f /tmp/sip-redirect-\${VERSION}.tar.gz

              echo 'Deployed version: '\${VERSION}

              # --- Phase 2: Update systemd and restart ---

              # Update systemd unit to use venv
              echo '${UNIT_B64}' | base64 -d > /etc/systemd/system/vvp-sip-redirect.service

              # Ensure env file exists with required vars
              mkdir -p /etc/vvp
              if [ ! -f /etc/vvp/sip-redirect.env ]; then
                touch /etc/vvp/sip-redirect.env
              fi

              # Ensure monitor is enabled
              if ! grep -q 'VVP_MONITOR_ENABLED' /etc/vvp/sip-redirect.env; then
                echo 'VVP_MONITOR_ENABLED=true' >> /etc/vvp/sip-redirect.env
              fi

              # Update GIT_SHA to current deployment
              sed -i '/^GIT_SHA=/d' /etc/vvp/sip-redirect.env
              echo 'GIT_SHA=${VERSION}' >> /etc/vvp/sip-redirect.env

              # Reload and restart
              systemctl daemon-reload
              systemctl restart vvp-sip-redirect

              # Wait for startup
              sleep 5
              systemctl is-active vvp-sip-redirect
            "

      - name: Verify deployed version
        run: |
          EXPECTED="${{ github.sha }}"
          # Status server listens on port 8085 (configured via VVP_STATUS_HTTP_PORT
          # in /etc/vvp/sip-redirect.env). Port is not exposed externally through
          # the Azure NSG, so we verify via az vm run-command.
          # Brief pause to let the run-command extension fully release.
          sleep 15
          for i in {1..6}; do
            RESULT=$(az vm run-command invoke \
              --resource-group VVP --name vvp-pbx \
              --command-id RunShellScript \
              --scripts "curl -sf --max-time 5 http://localhost:8085/version 2>/dev/null || echo '{}'" \
              --query "value[0].message" -o tsv 2>/dev/null)
            DEPLOYED=$(echo "$RESULT" | grep -o '"git_sha": *"[^"]*"' | head -1 | sed 's/.*"git_sha": *"//;s/"//' || echo "")
            if [ "$DEPLOYED" = "$EXPECTED" ]; then
              echo "Version verified: ${DEPLOYED:0:7}"
              exit 0
            fi
            echo "Attempt $i/6: expected ${EXPECTED:0:7}, got ${DEPLOYED:0:7}"
            sleep 10
          done
          echo "::error::SIP Redirect version mismatch after 1 minute"
          exit 1

      - name: Rollback on failure
        if: failure()
        run: |
          az vm run-command invoke \
            --resource-group VVP --name vvp-pbx \
            --command-id RunShellScript \
            --scripts "
              # List available releases
              echo 'Available releases:'
              ls -t /opt/vvp/sip-redirect/releases | head -5

              # Get previous release
              PREV=\$(ls -t /opt/vvp/sip-redirect/releases | sed -n '2p')
              if [ -n \"\$PREV\" ]; then
                ln -sfn /opt/vvp/sip-redirect/releases/\$PREV /opt/vvp/sip-redirect/current
                systemctl restart vvp-sip-redirect
                echo 'Rolled back to: '\$PREV
              else
                echo 'No previous release available for rollback'
              fi
            "

  # =========================================================================
  # DEPLOY SIP VERIFY SERVICE (PBX VM)
  # =========================================================================
  # Deploys to vvp-pbx VM with atomic symlink switch and rollback capability
  # Only runs when sip-verify code changes and tests pass
  deploy-sip-verify:
    needs: [changes, test-sip-verify, deploy-sip-redirect]
    if: needs.changes.outputs.sip-verify == 'true' && !failure()
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Package service
        run: |
          VERSION="${{ github.sha }}"
          tar -czf "sip-verify-${VERSION}.tar.gz" -C services/sip-verify app/ pyproject.toml
          echo "Created package: sip-verify-${VERSION}.tar.gz"
          ls -la "sip-verify-${VERSION}.tar.gz"

      - name: Upload to Azure Blob
        run: |
          VERSION="${{ github.sha }}"
          az storage blob upload \
            --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
            --container-name deployments \
            --name "sip-verify/sip-verify-${VERSION}.tar.gz" \
            --file "sip-verify-${VERSION}.tar.gz" \
            --auth-mode login \
            --overwrite

      - name: Generate short-lived SAS URL (5 min expiry)
        id: sas
        run: |
          VERSION="${{ github.sha }}"
          EXPIRY=$(date -u -d "+5 minutes" '+%Y-%m-%dT%H:%MZ')
          SAS_URL=$(az storage blob generate-sas \
            --account-name ${{ secrets.AZURE_STORAGE_ACCOUNT }} \
            --container-name deployments \
            --name "sip-verify/sip-verify-${VERSION}.tar.gz" \
            --permissions r \
            --expiry "$EXPIRY" \
            --auth-mode login \
            --as-user \
            --full-uri \
            --output tsv)
          echo "url=$SAS_URL" >> $GITHUB_OUTPUT

      - name: Deploy with atomic symlink switch
        run: |
          VERSION="${{ github.sha }}"
          SAS_URL="${{ steps.sas.outputs.url }}"
          az vm run-command invoke \
            --resource-group VVP --name vvp-pbx \
            --command-id RunShellScript \
            --scripts "
              set -e
              VERSION='${VERSION}'
              DEPLOY_DIR=/opt/vvp/sip-verify

              # Download using SAS URL (no az CLI needed on VM)
              curl -sSL -o /tmp/sip-verify-\${VERSION}.tar.gz '${SAS_URL}'

              # Extract to versioned directory
              mkdir -p \${DEPLOY_DIR}/releases/\${VERSION}
              tar -xzf /tmp/sip-verify-\${VERSION}.tar.gz -C \${DEPLOY_DIR}/releases/\${VERSION}

              # Atomic symlink switch
              ln -sfn \${DEPLOY_DIR}/releases/\${VERSION} \${DEPLOY_DIR}/current.new
              mv -Tf \${DEPLOY_DIR}/current.new \${DEPLOY_DIR}/current

              # Cleanup old releases (keep last 3)
              cd \${DEPLOY_DIR}/releases && ls -t | tail -n +4 | xargs -r rm -rf

              # Cleanup temp file
              rm -f /tmp/sip-verify-\${VERSION}.tar.gz

              echo 'Deployed version: '\${VERSION}
            "

      - name: Ensure systemd unit and restart
        run: |
          # Create systemd unit content (base64 encoded to avoid YAML issues)
          UNIT_B64=$(echo -e '[Unit]\nDescription=VVP SIP Verification Service\nAfter=network.target\n\n[Service]\nType=simple\nUser=root\nEnvironmentFile=/etc/vvp/sip-verify.env\nWorkingDirectory=/opt/vvp/sip-verify/current\nExecStart=/usr/bin/python3 -m app.main\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n' | base64 -w0)

          # Create env file content (base64 encoded)
          ENV_B64=$(echo -e 'VVP_VERIFIER_URL=https://vvp-verifier.rcnx.io\nVVP_SIP_VERIFY_PORT=5071\nVVP_REDIRECT_TARGET=127.0.0.1:5080\nPYTHONPATH=/opt/vvp/common-pkg/common\nLOG_LEVEL=INFO\n' | base64 -w0)

          az vm run-command invoke \
            --resource-group VVP --name vvp-pbx \
            --command-id RunShellScript \
            --scripts "
              set -e

              # Create systemd unit if not exists
              if [ ! -f /etc/systemd/system/vvp-sip-verify.service ]; then
                echo '${UNIT_B64}' | base64 -d > /etc/systemd/system/vvp-sip-verify.service
                systemctl daemon-reload
                systemctl enable vvp-sip-verify
                echo 'Created systemd unit'
              fi

              # Create env file if not exists
              if [ ! -f /etc/vvp/sip-verify.env ]; then
                mkdir -p /etc/vvp
                echo '${ENV_B64}' | base64 -d > /etc/vvp/sip-verify.env
                chmod 600 /etc/vvp/sip-verify.env
                echo 'Created env file'
              fi

              # Reload and restart
              systemctl daemon-reload
              systemctl restart vvp-sip-verify

              # Wait for startup
              sleep 5
              systemctl is-active vvp-sip-verify
            "

      - name: Verify service listening
        run: |
          sleep 5
          az vm run-command invoke \
            --resource-group VVP --name vvp-pbx \
            --command-id RunShellScript \
            --scripts "
              if ss -ulnp | grep -q ':5071'; then
                echo 'SIP Verify service listening on port 5071'
              else
                echo 'WARNING: Service not listening on port 5071'
                journalctl -u vvp-sip-verify -n 20 --no-pager
                exit 1
              fi
            "

      - name: Rollback on failure
        if: failure()
        run: |
          az vm run-command invoke \
            --resource-group VVP --name vvp-pbx \
            --command-id RunShellScript \
            --scripts "
              # List available releases
              echo 'Available releases:'
              ls -t /opt/vvp/sip-verify/releases 2>/dev/null | head -5 || echo 'No releases found'

              # Get previous release
              PREV=\$(ls -t /opt/vvp/sip-verify/releases 2>/dev/null | sed -n '2p')
              if [ -n \"\$PREV\" ]; then
                ln -sfn /opt/vvp/sip-verify/releases/\$PREV /opt/vvp/sip-verify/current
                systemctl restart vvp-sip-verify
                echo 'Rolled back to: '\$PREV
              else
                echo 'No previous release available for rollback'
              fi
            "

  # =========================================================================
  # DEPLOY PBX CONFIGURATION
  # =========================================================================
  # Deploys dialplan configuration to PBX VM
  # Only runs when pbx-config changes
  deploy-pbx-config:
    needs: [changes, deploy-sip-redirect, deploy-sip-verify]
    if: needs.changes.outputs.pbx-config == 'true' && !failure()
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy dialplan (single command)
        run: |
          # Combine backup, deploy, and reload into a single VM command
          # This reduces conflicts with other az vm run-command operations
          if [ -f "services/pbx/config/public-sip.xml" ]; then
            CONTENT=$(base64 -w0 "services/pbx/config/public-sip.xml")
            echo "Deploying dialplan..."
            az vm run-command invoke \
              --resource-group VVP --name vvp-pbx \
              --command-id RunShellScript \
              --scripts "
                set -e
                BACKUP_DIR=/etc/freeswitch/dialplan/backup
                mkdir -p \$BACKUP_DIR
                cp /etc/freeswitch/dialplan/public.xml \$BACKUP_DIR/public.xml.\$(date +%Y%m%d%H%M%S) 2>/dev/null || true
                echo '$CONTENT' | base64 -d > /etc/freeswitch/dialplan/public.xml
                chown www-data:www-data /etc/freeswitch/dialplan/public.xml
                fs_cli -x 'reloadxml'
                echo 'Dialplan deployed and reloaded successfully'
              "
          fi
